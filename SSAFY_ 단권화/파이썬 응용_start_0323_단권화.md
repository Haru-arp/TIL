# APS (Algorithm Problem Solving) 응용 

>
>
>- SW 문제 해결
>- 복잡도 분석
>- 표준 입출력 방법
>- 비트 연산
>- 진수
>- 실수

<hr>

# **SW 문제 해결**

## SW 문제 해결 역량이란

- 프로그램을 하기 위한 많은 제약 조건과 요구사항을 이해하고 최선의 방법을 찾아내는 것.
- 프로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재 적소에 퍼즐을 배치하든 연결하여 큰 그림을 만드는 능력
- 문제 해결 역량은 추상적인 기술이다. 
- 문제 해결 역량을 향상시키기 위해서 훈련이 필요하다.

## 문제 해결 능력을 훈련하기 위해서는

- 일부 새로운 언어, 프레임워크, 개발 방법론만을 배워나가는것으로 충분하지 않다. 이들을 조합해 나가는 방법을 배워야 하지만 쉽지 않다.
- 경험을 통해서 나아지리라 막연히 짐작만 한다. 그러나 경험에서는 문제 해결 능력을 개발 할 수 있는 상황이 항상 주어지는 것이 아니며, 또한 그런 상황에서 자기 개발을 하기는 쉽지 않다.
- 상황을 인위적으로 만들어 훈련해야 한다. 즉 잘 정제된 추상적인 문제를 제시하고 이를 해결해 가면서 문제 해결 능력을 향상 시킬 수 있는 훈련이 필요하다.

## 문제 해결 과정

1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

## 문제 해결 전략

- 직관과 체계적인 접근

## 체계적인 접근을 위한 질문들

- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 단순화 할 수 있을까?
- 그림으로 그려 볼 수 있을까?
- 수식으로 표현 할 수 있을까?
- 문제를 분해 할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?
- ...

<hr>

# **복잡도 분석**

## 알고리즘?

- (명) 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

    주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차.

## 알고리즘의 효율

- 공간적 효율성과 시간적 효율성
    - 공간적 효율성은 연산량 대비 얼마나 적은 메모리 공간을 요하는 가를 말한다.
    - 시간적 효율성은 연산량 대비 얼마나 적은 시간을 요하는 가를 말한다.
    - 효율성을 뒤집어 표현하면 복잡도 (Complexity)가 된다. 복잡도가 높을수록 효율성은 저하된다.

## 알고리즘의 효율

- 시간적 복잡도 분석
    - 하드웨어 환경에 따라 처리시간이 달라진다.
        - 부동 소수 처리 프로세서 존재 유무, 나눗셈 가속 기능 유무
        - 입출력 장비의 성능, 공유 여부
    - 소프트웨어 환경에 따라 처리시간이 달라진다.
        - 프로그램 언어의 종류
        - 운영체제, 컴파일러의 종류
    - 이러한 환경 차이로 인해 분석이 어렵다.

## 복잡도의 점근적 표기

- 시간 (또는 공간) 복잡도는 입력 크기에 대한 함수로 표기하는데, 이 함수는 주로 여러 개의 항을 가지는 다항식이다.
- 이를 단순한 함수로 표현하기 위해 점근적 표기( Asymptotic Notation)를 사용한다.
- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법이다.
    - O(Big-oh)- 표기
    - (Big-Omega)표기
    - Big-Theta 표기

## O(Big-Oh)표기

- O- 표기는 복잡도의 점근적 상한을 나타낸다.
- 복잡도가 f(n) = 2n^2 - 7n + 4 이라면, f(n) 의 O- 표기는 O(n^2)이다.
- 먼저 f(n)의 단순화 된 표현은 n^2이다.
- 단순화된 함수 n^2에 임의의 상수 c를 곱한 cn^2이  n이 증가함에 따라 f(n)의 상한이 된다. (단, C > 0.)

<img src="%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%9D%91%EC%9A%A9_start_0323_%EB%8B%A8%EA%B6%8C%ED%99%94.assets/image-20220323173009573.png" alt="image-20220323173009573" style="zoom:67%;" />

## 복잡도 f(n)과 O-표기를 그래프로 나타내고 있다.

## n이 증가함에 따라 O(g(n))이 점근적 상한이라는 것 (즉, g(n)이 n0보다 큰 모든 n에 대해서 항상 f(n)보다 크다는 것) 을 보여준다.

![image-20220323173120564](%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%9D%91%EC%9A%A9_start_0323_%EB%8B%A8%EA%B6%8C%ED%99%94.assets/image-20220323173120564.png)

## Big-Omega 표기

- 복잡도의 점근적 하한을 의미한다.![image-20220323173157187](%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%9D%91%EC%9A%A9_start_0323_%EB%8B%A8%EA%B6%8C%ED%99%94.assets/image-20220323173157187.png)

<img src="%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%9D%91%EC%9A%A9_start_0323_%EB%8B%A8%EA%B6%8C%ED%99%94.assets/image-20220323173205904.png" alt="image-20220323173205904" style="zoom: 67%;" />

## Theta - 표기

![image-20220323173251969](%ED%8C%8C%EC%9D%B4%EC%8D%AC%20%EC%9D%91%EC%9A%A9_start_0323_%EB%8B%A8%EA%B6%8C%ED%99%94.assets/image-20220323173251969.png)

## 자주 사용하는 O-표기

- O(1) 상수 시간
- O(logn) 로그(대수)시간
- O(n) 선형 시간
- O(nlogn) 로그 선형 시간
- O(n^2) 제곱 시간
- O(n^3) 세제곱 시간
- O(2^n) 지수 시간



# 비트 연산

